// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: values_sequence.gen.go.tmpl

package gen

import (
	"github.com/influxdata/influxdb/tsdb"
)

type FloatValuesSequence interface {
	Reset()
	Write(v []float64)
}

type TimeFloatValuesSequence struct {
	vals  FloatArray
	ts    TimestampSequence
	vs    FloatValuesSequence
	count int
	n     int
}

func NewTimeFloatValuesSequence(count int, ts TimestampSequence, vs FloatValuesSequence) TimeValuesSequence {
	return &TimeFloatValuesSequence{
		vals:  *NewFloatArrayLen(tsdb.DefaultMaxPointsPerBlock),
		ts:    ts,
		vs:    vs,
		count: count,
		n:     count,
	}
}

func (s *TimeFloatValuesSequence) Reset() {
	s.ts.Reset()
	s.vs.Reset()
	s.n = s.count
}

func (s *TimeFloatValuesSequence) Next() bool {
	if s.n > 0 {
		c := min(s.n, tsdb.DefaultMaxPointsPerBlock)
		s.n -= c
		s.vals.Timestamps = s.vals.Timestamps[:c]
		s.vals.Values = s.vals.Values[:c]

		s.ts.Write(s.vals.Timestamps)
		s.vs.Write(s.vals.Values)
		return true
	}

	return false
}

func (s *TimeFloatValuesSequence) Values() Values {
	return &s.vals
}

type IntegerValuesSequence interface {
	Reset()
	Write(v []int64)
}

type TimeIntegerValuesSequence struct {
	vals  IntegerArray
	ts    TimestampSequence
	vs    IntegerValuesSequence
	count int
	n     int
}

func NewTimeIntegerValuesSequence(count int, ts TimestampSequence, vs IntegerValuesSequence) TimeValuesSequence {
	return &TimeIntegerValuesSequence{
		vals:  *NewIntegerArrayLen(tsdb.DefaultMaxPointsPerBlock),
		ts:    ts,
		vs:    vs,
		count: count,
		n:     count,
	}
}

func (s *TimeIntegerValuesSequence) Reset() {
	s.ts.Reset()
	s.vs.Reset()
	s.n = s.count
}

func (s *TimeIntegerValuesSequence) Next() bool {
	if s.n > 0 {
		c := min(s.n, tsdb.DefaultMaxPointsPerBlock)
		s.n -= c
		s.vals.Timestamps = s.vals.Timestamps[:c]
		s.vals.Values = s.vals.Values[:c]

		s.ts.Write(s.vals.Timestamps)
		s.vs.Write(s.vals.Values)
		return true
	}

	return false
}

func (s *TimeIntegerValuesSequence) Values() Values {
	return &s.vals
}

type UnsignedValuesSequence interface {
	Reset()
	Write(v []uint64)
}

type TimeUnsignedValuesSequence struct {
	vals  UnsignedArray
	ts    TimestampSequence
	vs    UnsignedValuesSequence
	count int
	n     int
}

func NewTimeUnsignedValuesSequence(count int, ts TimestampSequence, vs UnsignedValuesSequence) TimeValuesSequence {
	return &TimeUnsignedValuesSequence{
		vals:  *NewUnsignedArrayLen(tsdb.DefaultMaxPointsPerBlock),
		ts:    ts,
		vs:    vs,
		count: count,
		n:     count,
	}
}

func (s *TimeUnsignedValuesSequence) Reset() {
	s.ts.Reset()
	s.vs.Reset()
	s.n = s.count
}

func (s *TimeUnsignedValuesSequence) Next() bool {
	if s.n > 0 {
		c := min(s.n, tsdb.DefaultMaxPointsPerBlock)
		s.n -= c
		s.vals.Timestamps = s.vals.Timestamps[:c]
		s.vals.Values = s.vals.Values[:c]

		s.ts.Write(s.vals.Timestamps)
		s.vs.Write(s.vals.Values)
		return true
	}

	return false
}

func (s *TimeUnsignedValuesSequence) Values() Values {
	return &s.vals
}

type StringValuesSequence interface {
	Reset()
	Write(v []string)
}

type TimeStringValuesSequence struct {
	vals  StringArray
	ts    TimestampSequence
	vs    StringValuesSequence
	count int
	n     int
}

func NewTimeStringValuesSequence(count int, ts TimestampSequence, vs StringValuesSequence) TimeValuesSequence {
	return &TimeStringValuesSequence{
		vals:  *NewStringArrayLen(tsdb.DefaultMaxPointsPerBlock),
		ts:    ts,
		vs:    vs,
		count: count,
		n:     count,
	}
}

func (s *TimeStringValuesSequence) Reset() {
	s.ts.Reset()
	s.vs.Reset()
	s.n = s.count
}

func (s *TimeStringValuesSequence) Next() bool {
	if s.n > 0 {
		c := min(s.n, tsdb.DefaultMaxPointsPerBlock)
		s.n -= c
		s.vals.Timestamps = s.vals.Timestamps[:c]
		s.vals.Values = s.vals.Values[:c]

		s.ts.Write(s.vals.Timestamps)
		s.vs.Write(s.vals.Values)
		return true
	}

	return false
}

func (s *TimeStringValuesSequence) Values() Values {
	return &s.vals
}

type BooleanValuesSequence interface {
	Reset()
	Write(v []bool)
}

type TimeBooleanValuesSequence struct {
	vals  BooleanArray
	ts    TimestampSequence
	vs    BooleanValuesSequence
	count int
	n     int
}

func NewTimeBooleanValuesSequence(count int, ts TimestampSequence, vs BooleanValuesSequence) TimeValuesSequence {
	return &TimeBooleanValuesSequence{
		vals:  *NewBooleanArrayLen(tsdb.DefaultMaxPointsPerBlock),
		ts:    ts,
		vs:    vs,
		count: count,
		n:     count,
	}
}

func (s *TimeBooleanValuesSequence) Reset() {
	s.ts.Reset()
	s.vs.Reset()
	s.n = s.count
}

func (s *TimeBooleanValuesSequence) Next() bool {
	if s.n > 0 {
		c := min(s.n, tsdb.DefaultMaxPointsPerBlock)
		s.n -= c
		s.vals.Timestamps = s.vals.Timestamps[:c]
		s.vals.Values = s.vals.Values[:c]

		s.ts.Write(s.vals.Timestamps)
		s.vs.Write(s.vals.Values)
		return true
	}

	return false
}

func (s *TimeBooleanValuesSequence) Values() Values {
	return &s.vals
}
